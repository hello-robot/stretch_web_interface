/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/pages/robot/js/robot.ts":
/*!*************************************!*\
  !*** ./src/pages/robot/js/robot.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ALL_JOINTS\": () => (/* binding */ ALL_JOINTS),\n/* harmony export */   \"Robot\": () => (/* binding */ Robot),\n/* harmony export */   \"getJointEffort\": () => (/* binding */ getJointEffort),\n/* harmony export */   \"getJointValue\": () => (/* binding */ getJointValue)\n/* harmony export */ });\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module 'roslib'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n\nconst ALL_JOINTS = ['joint_head_tilt', 'joint_head_pan', 'joint_gripper_finger_left', 'wrist_extension', 'joint_lift', 'joint_wrist_yaw', \"translate_mobile_base\", \"rotate_mobile_base\", 'gripper_aperture'];\nconst JOINT_LIMITS = {\n    \"wrist_extension\": [0, .52],\n    \"joint_wrist_yaw\": [-1.75, 4],\n    \"joint_lift\": [0, 1.1],\n    \"translate_mobile_base\": [-30.0, 30.0],\n    \"rotate_mobile_base\": [-3.14, 3.14],\n};\nclass Robot {\n    ros;\n    inSim;\n    tfCallback;\n    jointStateCallback;\n    // TODO (kavidey): check whether this variable is necessary, we never read from it\n    // private currentJointTrajectoryGoal\n    currentTrajectoryKillInterval; // same as lookAtGripperInterval, should be `typeof setTimeout`\n    panOffset = 0;\n    tiltOffset = 0;\n    tfClient;\n    trajectoryClient;\n    jointStateTopic;\n    linkGripperFingerLeftTF;\n    linkHeadTiltTF;\n    cameraColorFrameTF;\n    baseTF;\n    jointState;\n    videoTopics = [];\n    isWristFollowingActive = false;\n    // TODO (kavidey): this should be `typeof setTimeout`, but TS wants it to be number\n    lookAtGripperInterval;\n    commands = {\n        \"drive\": {\n            \"forward\": (size) => {\n                this.executeIncrementalMove(\"translate_mobile_base\", size);\n            },\n            \"backward\": (size) => {\n                this.executeIncrementalMove(\"translate_mobile_base\", -size);\n            },\n            \"turn_right\": (size) => {\n                this.executeIncrementalMove(\"rotate_mobile_base\", -size);\n            },\n            \"turn_left\": (size) => {\n                this.executeIncrementalMove(\"rotate_mobile_base\", size);\n            },\n            \"turn_ccw\": (_) => {\n                this.baseTurn(Math.PI / 2);\n            },\n            \"turn_cw\": (_) => {\n                this.baseTurn(-Math.PI / 2);\n            }\n        },\n        \"lift\": {\n            \"up\": (size) => {\n                this.executeIncrementalMove(\"joint_lift\", size);\n            },\n            \"down\": (size) => {\n                this.executeIncrementalMove(\"joint_lift\", -size);\n            }\n        },\n        \"arm\": {\n            \"extend\": (size) => {\n                this.executeIncrementalMove(\"wrist_extension\", size);\n            },\n            \"retract\": (size) => {\n                this.executeIncrementalMove(\"wrist_extension\", -size);\n            }\n        },\n        \"wrist\": {\n            \"in\": (size) => {\n                this.executeIncrementalMove(\"joint_wrist_yaw\", size);\n            },\n            \"out\": (size) => {\n                this.executeIncrementalMove(\"joint_wrist_yaw\", -size);\n            },\n            \"stop_all_motion\": () => {\n                this.wristStopMotion();\n            },\n            \"bend_velocity\": (deg_per_sec) => {\n                this.wristBendVelocity(deg_per_sec);\n            },\n            \"auto_bend\": (ang_deg) => {\n                this.wristAutoBend(ang_deg);\n            },\n            \"init_fixed_wrist\": (vsize, vscalesize) => {\n                this.initFixedWrist();\n            },\n            \"bend_up\": (vsize, vscalesize) => {\n                this.wristBend(5.0); // attempt to bed the wrist upward by 5 degrees\n            },\n            \"bend_down\": (vsize, vscalesize) => {\n                this.wristBend(-5.0); // attempt to bed the wrist downward by 5 degrees\n            },\n            \"roll_left\": (vsize, vscalesize) => {\n                this.wristRoll(-5.0); // attempt to roll the wrist to the left (clockwise) by 5 degrees\n            },\n            \"roll_right\": (vsize, vscalesize) => {\n                this.wristRoll(5.0); // attempt to roll the wrist to the right (counterclockwise) by 5 degrees\n            }\n        },\n        \"gripper\": {\n            \"set_goal\": (goalWidthCm) => {\n                this.gripperGoalAperture(goalWidthCm);\n            },\n            \"open\": (vsize, vscalesize) => {\n                this.gripperDeltaAperture(1.0);\n            },\n            \"close\": (vsize, vscalesize) => {\n                this.gripperDeltaAperture(-1.0);\n            },\n            \"configure_camera\": (configuration) => {\n                // TODO (kavidey): Implement or remove this\n            }\n        },\n        \"head\": {\n            \"up\": (size) => {\n                this.executeIncrementalMove(\"joint_head_tilt\", size);\n            },\n            \"down\": (size) => {\n                this.executeIncrementalMove(\"joint_head_tilt\", -size);\n            },\n            \"left\": (size) => {\n                this.executeIncrementalMove(\"joint_head_pan\", size);\n            },\n            \"right\": (size) => {\n                this.executeIncrementalMove(\"joint_head_pan\", -size);\n            },\n            \"gripper_follow\": (value) => {\n                this.setPanTiltFollowGripper(value);\n            },\n            \"configure_overhead_camera\": (configuration) => {\n                // TODO (kavidey): Implement or remove this\n            }\n        },\n        \"full\": {\n            \"pose\": (pose) => {\n                this.goToPose(pose);\n            }\n        }\n    };\n    constructor(jointStateCallback, tfCallback) {\n        this.jointStateCallback = jointStateCallback;\n        this.tfCallback = tfCallback;\n    }\n    async connect() {\n        // connect to rosbridge websocket\n        let ros = new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'roslib'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())({\n            url: 'wss://localhost:9090'\n        });\n        ros.on('connection', () => {\n            let simTime = new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'roslib'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())({\n                ros: ros,\n                name: '/use_sim_time'\n            });\n            simTime.get(value => {\n                this.inSim = value;\n            });\n            this.onConnect(ros);\n        });\n        ros.on('error', (error) => {\n            throw error;\n        });\n        ros.on('close', () => {\n            throw 'Connection to websocket has been closed.';\n        });\n    }\n    async onConnect(ros) {\n        this.ros = ros;\n        this.jointStateTopic = new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'roslib'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())({\n            ros: this.ros,\n            name: '/stretch/joint_states/',\n            messageType: 'sensor_msgs/JointState'\n        });\n        this.jointStateTopic.subscribe(message => {\n            if (this.jointState === null) {\n                console.log('Received first joint state from ROS topic ' + this.jointStateTopic?.name);\n            }\n            this.jointState = message;\n            if (this.jointStateCallback)\n                this.jointStateCallback(message);\n        });\n        this.tfClient = new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'roslib'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())({\n            ros: this.ros,\n            fixedFrame: 'base_link',\n            angularThres: 0.01,\n            transThres: 0.01\n        });\n        this.tfClient.subscribe('link_gripper_finger_left', transform => {\n            this.linkGripperFingerLeftTF = transform;\n            if (this.tfCallback) {\n                this.tfCallback('link_gripper_finger_left', transform);\n            }\n        });\n        this.tfClient.subscribe('link_head_tilt', transform => {\n            this.linkHeadTiltTF = transform;\n            if (this.tfCallback) {\n                this.tfCallback('link_head_tilt', transform);\n            }\n        });\n        this.tfClient.subscribe('camera_color_frame', transform => {\n            this.cameraColorFrameTF = transform;\n            if (this.tfCallback) {\n                this.tfCallback('camera_color_frame', transform);\n            }\n        });\n        this.tfClient.subscribe('odom', transform => {\n            this.baseTF = transform;\n        });\n        this.trajectoryClient = new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'roslib'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())({\n            ros: this.ros,\n            serverName: '/stretch_controller/follow_joint_trajectory',\n            actionName: 'control_msgs/FollowJointTrajectoryAction',\n            timeout: 100 // TODO (kavidey): Figure out what unit this is and update\n        });\n    }\n    subscribeToVideo(topicName, callback) {\n        let topic = new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'roslib'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())({\n            ros: this.ros,\n            name: topicName,\n            messageType: 'sensor_msgs/CompressedImage'\n        });\n        this.videoTopics.push(topic);\n        topic.subscribe(callback);\n    }\n    ////////////////////////////////////////////////////////////////////////////////////\n    baseTranslate(dist) {\n        if (!this.trajectoryClient)\n            throw 'trajectoryClient is undefined';\n        makePoseGoal({ 'translate_mobile_base': dist }, this.trajectoryClient).send();\n    }\n    baseTurn(ang_deg) {\n        // angle in degrees\n        // velocity in centimeter / second (linear wheel velocity - same as BaseTranslate)\n        if (!this.trajectoryClient)\n            throw 'trajectoryClient is undefined';\n        makePoseGoal({ 'rotate_mobile_base': ang_deg }, this.trajectoryClient).send();\n    }\n    makeIncrementalMoveGoal(jointName, jointValueInc) {\n        if (!this.jointState)\n            throw 'jointState is undefined';\n        let newJointValue = getJointValue(this.jointState, jointName);\n        // Paper over Hello's fake joints\n        if (jointName === \"translate_mobile_base\" || jointName === \"rotate_mobile_base\") {\n            // These imaginary joints are floating, always have 0 as their reference\n            newJointValue = 0;\n        }\n        else if (jointName === \"gripper_aperture\") {\n            newJointValue = getJointValue(this.jointState, \"joint_gripper_finger_left\");\n        }\n        newJointValue = newJointValue + jointValueInc;\n        let pose = { [jointName]: newJointValue };\n        if (!this.trajectoryClient)\n            throw 'trajectoryClient is undefined';\n        return makePoseGoal(pose, this.trajectoryClient);\n    }\n    setPanTiltFollowGripper(value) {\n        // Idempotent: setting same value has no effect\n        if (this.isWristFollowingActive === value)\n            return;\n        this.isWristFollowingActive = value;\n        if (value) {\n            this.panOffset = 0;\n            this.tiltOffset = 0;\n            let lookIfReadyAndRepeat = () => {\n                if (this.linkGripperFingerLeftTF && this.linkHeadTiltTF) {\n                    this.lookAtGripper(this.panOffset, this.tiltOffset);\n                }\n                this.lookAtGripperInterval = window.setTimeout(lookIfReadyAndRepeat, 500);\n            };\n            lookIfReadyAndRepeat();\n        }\n        else {\n            clearTimeout(this.lookAtGripperInterval);\n            // this.lookAtGripperInterval = null\n        }\n        return true;\n    }\n    lookAtGripper(panOffset, tiltOffset) {\n        if (!this.linkGripperFingerLeftTF)\n            throw 'linkGripperFingerLeftTF is undefined';\n        if (!this.linkHeadTiltTF)\n            throw 'linkHeadTiltTF is undefined';\n        let posDifference = {\n            x: this.linkGripperFingerLeftTF.translation.x - this.linkHeadTiltTF.translation.x,\n            y: this.linkGripperFingerLeftTF.translation.y - this.linkHeadTiltTF.translation.y,\n            z: this.linkGripperFingerLeftTF.translation.z - this.linkHeadTiltTF.translation.z\n        };\n        // Normalize posDifference\n        const scalar = Math.sqrt(posDifference.x ** 2 + posDifference.y ** 2 + posDifference.z ** 2);\n        posDifference.x /= scalar;\n        posDifference.y /= scalar;\n        posDifference.z /= scalar;\n        const pan = Math.atan2(posDifference.y, posDifference.x) + this.panOffset;\n        const tilt = Math.atan2(posDifference.z, -posDifference.y) + this.tiltOffset;\n        if (!this.jointState)\n            throw 'jointState is undefined';\n        let panDiff = Math.abs(getJointValue(this.jointState, \"joint_head_pan\") - pan);\n        let tiltDiff = Math.abs(getJointValue(this.jointState, \"joint_head_tilt\") - tilt);\n        // FIXME(nickswalker,2-1-22): Goals really close to current state cause some whiplash\n        //   these joints in simulation. Ignoring small goals hacks around this for now\n        // console.log(panDiff, tiltDiff)\n        if (panDiff < 0.02 && tiltDiff < 0.02) {\n            return;\n        }\n        if (!this.trajectoryClient)\n            throw 'trajectoryClient is undefined';\n        let headFollowPoseGoal = makePoseGoal({\n            'joint_head_pan': pan + panOffset,\n            'joint_head_tilt': tilt + tiltOffset\n        }, this.trajectoryClient);\n        headFollowPoseGoal.send();\n    }\n    gripperDeltaAperture(deltaWidthCm) {\n        // attempt to change the gripper aperture\n        try {\n            this.makeIncrementalMoveGoal('joint_gripper_finger_left', deltaWidthCm).send();\n        }\n        catch (e) {\n            console.warn(e);\n        }\n    }\n    headTilt(angRad) {\n        if (this.isWristFollowingActive) {\n            this.tiltOffset += angRad;\n        }\n        else {\n            try {\n                this.makeIncrementalMoveGoal('joint_head_tilt', angRad).send();\n            }\n            catch (e) {\n                console.warn(e);\n            }\n        }\n    }\n    headPan(angRad) {\n        if (this.isWristFollowingActive) {\n            this.panOffset += angRad;\n        }\n        else {\n            try {\n                this.makeIncrementalMoveGoal('joint_head_pan', angRad).send();\n            }\n            catch (e) {\n                console.warn(e);\n            }\n        }\n    }\n    goToPose(pose) {\n        if (!this.trajectoryClient)\n            throw 'trajectoryClient is undefined';\n        for (let key in pose) {\n            if (ALL_JOINTS.indexOf(key) === -1) {\n                console.error(`No such joint '${key}' from pose goal`);\n                return;\n            }\n        }\n        makePoseGoal(pose, this.trajectoryClient).send();\n    }\n    executeCommand(type, name, modifier) {\n        console.info(type, name, modifier);\n        this.commands[type][name](modifier);\n    }\n    executeIncrementalMove(jointName, increment) {\n        this.makeIncrementalMoveGoal(jointName, increment).send();\n    }\n    executeVelocityMove(jointName, velocity) {\n        this.stopExecution();\n        let velocities = [{}, {}];\n        velocities[0][jointName] = velocity;\n        velocities[1][jointName] = velocity;\n        let positions = [{}, {}];\n        if (!this.jointState)\n            throw 'jointState is undefined';\n        positions[0][jointName] = getJointValue(this.jointState, jointName);\n        const jointLimit = JOINT_LIMITS[jointName];\n        if (!jointLimit)\n            throw `Joint ${jointName} does not have limits`;\n        positions[1][jointName] = jointLimit[Math.sign(velocity) === -1 ? 0 : 1];\n        if (!this.trajectoryClient)\n            throw 'trajectoryClient is undefined';\n        makeVelocityGoal(positions, velocities, this.trajectoryClient).send();\n        this.affirmExecution();\n    }\n    affirmExecution() {\n        if (this.currentTrajectoryKillInterval) {\n            clearTimeout(this.currentTrajectoryKillInterval);\n        }\n        this.currentTrajectoryKillInterval = window.setTimeout(() => {\n            this.stopExecution();\n        }, 200);\n    }\n    stopExecution() {\n        if (!this.trajectoryClient)\n            throw 'trajectoryClient is undefined';\n        this.trajectoryClient.cancel();\n        // this.currentJointTrajectoryGoal = null\n        if (this.currentTrajectoryKillInterval) {\n            clearTimeout(this.currentTrajectoryKillInterval);\n            // this.currentTrajectoryKillInterval = null\n        }\n    }\n}\nfunction makePoseGoal(pose, trajectoryClient) {\n    let jointNames = [];\n    let jointPositions = [];\n    for (let key in pose) {\n        jointNames.push(key);\n        jointPositions.push(pose[key]);\n    }\n    let newGoal = new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'roslib'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())({\n        actionClient: trajectoryClient,\n        goalMessage: {\n            trajectory: {\n                header: {\n                    stamp: {\n                        secs: 0,\n                        nsecs: 0\n                    }\n                },\n                joint_names: jointNames,\n                points: [\n                    {\n                        positions: jointPositions,\n                        // The following might causing the jumpiness in continuous motions\n                        time_from_start: {\n                            secs: 0,\n                            nsecs: 1\n                        }\n                    }\n                ]\n            }\n        }\n    });\n    newGoal.on('feedback', function (feedback) {\n        //console.log('Feedback: ' + feedback);\n    });\n    newGoal.on('result', function (result) {\n        console.log('Final Result: ' + result);\n    });\n    return newGoal;\n}\nfunction makeVelocityGoal(positions, velocities, trajectoryClient) {\n    let points = [];\n    let jointNames;\n    for (let i = 0; i < positions.length; i++) {\n        let positionsT = positions[i];\n        let velocitiesT = velocities[i];\n        let positionsOut = [];\n        let velocitiesOut = [];\n        let names = [];\n        for (let key in positionsT) {\n            // Make sure that typescript knows that key will be a valid key\n            const typedKey = key;\n            names.push(typedKey);\n            positionsOut.push(positionsT[typedKey]);\n            velocitiesOut.push(velocitiesT[typedKey]);\n        }\n        points.push({\n            positions: positionsOut, velocities: velocitiesOut, time_from_start: {\n                secs: i * 60,\n                nsecs: 1\n            }\n        });\n        jointNames = names;\n    }\n    let newGoal = new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'roslib'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())({\n        actionClient: trajectoryClient,\n        goalMessage: {\n            trajectory: {\n                header: {\n                    stamp: {\n                        secs: 0,\n                        nsecs: 0\n                    }\n                },\n                joint_names: jointNames,\n                points: points\n            }\n        }\n    });\n    newGoal.on('feedback', function (feedback) {\n        //console.log('Feedback: ', feedback);\n    });\n    newGoal.on('result', function (result) {\n        console.log('Final Result: ', result);\n    });\n    return newGoal;\n}\nfunction getJointEffort(jointStateMessage, jointName) {\n    let jointIndex = jointStateMessage.name.indexOf(jointName);\n    return jointStateMessage.effort[jointIndex];\n}\nfunction getJointValue(jointStateMessage, jointName) {\n    // Paper over Hello's fake joint implementation\n    if (jointName === \"wrist_extension\") {\n        return getJointValue(jointStateMessage, \"joint_arm_l0\") +\n            getJointValue(jointStateMessage, \"joint_arm_l1\") +\n            getJointValue(jointStateMessage, \"joint_arm_l2\") +\n            getJointValue(jointStateMessage, \"joint_arm_l3\");\n    }\n    else if (jointName === \"translate_mobile_base\" || jointName === \"rotate_mobile_base\") {\n        return 0;\n    }\n    let jointIndex = jointStateMessage.name.indexOf(jointName);\n    return jointStateMessage.position[jointIndex];\n}\n\n\n//# sourceURL=webpack://hello-robot-server/./src/pages/robot/js/robot.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/pages/robot/js/robot.ts"](0, __webpack_exports__, __webpack_require__);
/******/ 	
/******/ })()
;